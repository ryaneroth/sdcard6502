ca65 V2.19 - Git db44d59f7
Main file   : test_dumpfile.s
Current file: test_dumpfile.s

000000r 1               zp_sd_address = $40         ; 2 bytes
000000r 1               zp_sd_currentsector = $42   ; 4 bytes
000000r 1               zp_fat32_variables = $46    ; 49 bytes
000000r 1               
000000r 1               fat32_workspace = $200      ; two pages
000000r 1               
000000r 1               buffer = $400
000000r 1               
000000r 1                 .org $a000
00A000  1  20 82 A8       jsr newline
00A003  1               reset:
00A003  1  A2 FF          ldx #$ff
00A005  1  9A             txs
00A006  1                 ; Initialise
00A006  1  20 90 A0       jsr via_init
00A009  1  20 9B A0       jsr sd_init
00A00C  1  20 58 A2       jsr fat32_init
00A00F  1  90 0E          bcc _initsuccess
00A011  1               
00A011  1                 ; Error during FAT32 initialization
00A011  1  A9 5A          lda #'Z'
00A013  1  20 8D A8       jsr print_char
00A016  1  AD 5A 00       lda fat32_errorstage
00A019  1  20 91 A8       jsr print_hex
00A01C  1  4C 8A A0       jmp loop
00A01F  1               
00A01F  1               _initsuccess:
00A01F  1               
00A01F  1                 ; Open root directory
00A01F  1  20 14 A5       jsr fat32_openroot
00A022  1               
00A022  1                 ; Find subdirectory by name
00A022  1  A2 B2          ldx #<subdirname
00A024  1  A0 A8          ldy #>subdirname
00A026  1  20 97 A7       jsr fat32_finddirent
00A029  1  90 1A          bcc _foundsubdir
00A02B  1               
00A02B  1                 ; Subdirectory not found
00A02B  1  20 82 A8       jsr newline
00A02E  1  A9 53          lda #'S'
00A030  1  20 8D A8       jsr print_char
00A033  1  A9 44          lda #'D'
00A035  1  20 8D A8       jsr print_char
00A038  1  A9 4E          lda #'N'
00A03A  1  20 8D A8       jsr print_char
00A03D  1  A9 46          lda #'F'
00A03F  1  20 8D A8       jsr print_char
00A042  1  4C 8A A0       jmp loop
00A045  1               
00A045  1               _foundsubdir:
00A045  1               
00A045  1                 ; Open subdirectory
00A045  1  20 4C A6       jsr fat32_opendirent
00A048  1               
00A048  1                 ; Find file by name
00A048  1  A2 BE          ldx #<filename
00A04A  1  A0 A8          ldy #>filename
00A04C  1  20 97 A7       jsr fat32_finddirent
00A04F  1  90 18          bcc _foundfile
00A051  1               
00A051  1                 ; File not found
00A051  1  20 82 A8       jsr newline
00A054  1  A9 46          lda #'F'
00A056  1  20 8D A8       jsr print_char
00A059  1  A9 4E          lda #'N'
00A05B  1  20 8D A8       jsr print_char
00A05E  1  A9 46          lda #'F'
00A060  1  20 8D A8       jsr print_char
00A063  1  20 8D A8       jsr print_char
00A066  1  4C 8A A0       jmp loop
00A069  1               
00A069  1               _foundfile:
00A069  1               
00A069  1                 ; Open file
00A069  1  20 4C A6       jsr fat32_opendirent
00A06C  1               
00A06C  1                 ; Read file contents into buffer
00A06C  1  A9 00          lda #<buffer
00A06E  1  8D 54 00       sta fat32_address
00A071  1  A9 04          lda #>buffer
00A073  1  8D 55 00       sta fat32_address+1
00A076  1               
00A076  1  20 62 A8       jsr fat32_file_read
00A079  1               
00A079  1               
00A079  1                 ; Dump data to terminal
00A079  1               
00A079  1  A2 00          ldx #0
00A07B  1               _printloop:
00A07B  1  BD 00 04       lda buffer,x
00A07E  1  20 A0 1E       jsr OUTCH
00A081  1               
00A081  1  E8             inx
00A082  1               
00A082  1  E0 10          cpx #16
00A084  1  D0 00          bne _not16
00A086  1               _not16:
00A086  1               
00A086  1  E0 20          cpx #32
00A088  1  D0 F1          bne _printloop
00A08A  1               
00A08A  1               
00A08A  1                 ; loop forever
00A08A  1               loop:
00A08A  1  20 4F 1C       jsr EXIT
00A08D  1  4C 8A A0       jmp loop
00A090  1               
00A090  1                 .include "hwconfig.s"
00A090  2               PORTA = $1700
00A090  2               DDRA = $1701
00A090  2               PORTB = $1702
00A090  2               DDRB = $1703
00A090  2               
00A090  2               OUTCH = $1EA0
00A090  2               GETCH = $1E5A
00A090  2               
00A090  2               EXIT  = $1C4F
00A090  2               
00A090  2               SD_CS   = %00010000
00A090  2               SD_SCK  = %00001000
00A090  2               SD_MOSI = %00000100
00A090  2               SD_MISO = %00000010
00A090  2               
00A090  2               PORTA_OUTPUTPINS = SD_CS | SD_SCK | SD_MOSI
00A090  2               
00A090  2               via_init:
00A090  2  A9 FF          lda #%11111111          ; Set all pins on port B to output
00A092  2  8D 03 17       sta DDRB
00A095  2  A9 1C          lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
00A097  2  8D 01 17       sta DDRA
00A09A  2  60             rts
00A09B  2               
00A09B  1                 .include "libsd.s"
00A09B  2               ; SD card interface module
00A09B  2               ;
00A09B  2               ; Requires zero-page variable storage:
00A09B  2               ;   zp_sd_address - 2 bytes
00A09B  2               ;   zp_sd_currentsector - 4 bytes
00A09B  2               
00A09B  2               sd_init:
00A09B  2                 ; Let the SD card boot up, by pumping the clock with SD CS disabled
00A09B  2               
00A09B  2                 ; We need to apply around 80 clock pulses with CS and MOSI high.
00A09B  2                 ; Normally MOSI doesn't matter when CS is high, but the card is
00A09B  2                 ; not yet is SPI mode, and in this non-SPI state it does care.
00A09B  2  A0 00          ldy #0
00A09D  2               _initretry:
00A09D  2  A9 14          lda #SD_CS | SD_MOSI
00A09F  2  A2 A0          ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
00A0A1  2               _preinitloop:
00A0A1  2  49 08          eor #SD_SCK
00A0A3  2  8D 00 17       sta PORTA
00A0A6  2  CA             dex
00A0A7  2  D0 F8          bne _preinitloop
00A0A9  2               
00A0A9  2               
00A0A9  2               _cmd0: ; GO_IDLE_STATE - resets card to idle state, and SPI mode
00A0A9  2  A9 10          lda #<sd_cmd0_bytes
00A0AB  2  85 40          sta zp_sd_address
00A0AD  2  A9 A1          lda #>sd_cmd0_bytes
00A0AF  2  85 41          sta zp_sd_address+1
00A0B1  2               
00A0B1  2  20 62 A1       jsr sd_sendcommand
00A0B4  2               
00A0B4  2                 ; Expect status response $01 (not initialized)
00A0B4  2  C9 01          cmp #$01
00A0B6  2  D0 4B          bne _initfailed
00A0B8  2               
00A0B8  2               _cmd8: ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
00A0B8  2  A9 16          lda #<sd_cmd8_bytes
00A0BA  2  85 40          sta zp_sd_address
00A0BC  2  A9 A1          lda #>sd_cmd8_bytes
00A0BE  2  85 41          sta zp_sd_address+1
00A0C0  2               
00A0C0  2  20 62 A1       jsr sd_sendcommand
00A0C3  2               
00A0C3  2                 ; Expect status response $01 (not initialized)
00A0C3  2  C9 01          cmp #$01
00A0C5  2  D0 3C          bne _initfailed
00A0C7  2               
00A0C7  2                 ; Read 32-bit return value, but ignore it
00A0C7  2  20 28 A1       jsr sd_readbyte
00A0CA  2  20 28 A1       jsr sd_readbyte
00A0CD  2  20 28 A1       jsr sd_readbyte
00A0D0  2  20 28 A1       jsr sd_readbyte
00A0D3  2               
00A0D3  2               _cmd55: ; APP_CMD - required prefix for ACMD commands
00A0D3  2  A9 1C          lda #<sd_cmd55_bytes
00A0D5  2  85 40          sta zp_sd_address
00A0D7  2  A9 A1          lda #>sd_cmd55_bytes
00A0D9  2  85 41          sta zp_sd_address+1
00A0DB  2               
00A0DB  2  20 62 A1       jsr sd_sendcommand
00A0DE  2               
00A0DE  2                 ; Expect status response $01 (not initialized)
00A0DE  2  C9 01          cmp #$01
00A0E0  2  D0 21          bne _initfailed
00A0E2  2               
00A0E2  2               _cmd41: ; APP_SEND_OP_COND - send operating conditions, initialize card
00A0E2  2  A9 22          lda #<sd_cmd41_bytes
00A0E4  2  85 40          sta zp_sd_address
00A0E6  2  A9 A1          lda #>sd_cmd41_bytes
00A0E8  2  85 41          sta zp_sd_address+1
00A0EA  2               
00A0EA  2  20 62 A1       jsr sd_sendcommand
00A0ED  2               
00A0ED  2                 ; Status response $00 means initialised
00A0ED  2  C9 00          cmp #$00
00A0EF  2  F0 11          beq _initialized
00A0F1  2               
00A0F1  2                 ; Otherwise expect status response $01 (not initialized)
00A0F1  2  C9 01          cmp #$01
00A0F3  2  D0 0E          bne _initfailed
00A0F5  2               
00A0F5  2                 ; Not initialized yet, so wait a while then try again.
00A0F5  2                 ; This retry is important, to give the card time to initialize.
00A0F5  2               
00A0F5  2  A2 00          ldx #0
00A0F7  2  A0 00          ldy #0
00A0F9  2               _delayloop:
00A0F9  2  88             dey
00A0FA  2  D0 FD          bne _delayloop
00A0FC  2  CA             dex
00A0FD  2  D0 FA          bne _delayloop
00A0FF  2               
00A0FF  2  4C D3 A0       jmp _cmd55
00A102  2               
00A102  2               
00A102  2               _initialized:
00A102  2                 ;lda #'Y'
00A102  2                 ;jsr print_char
00A102  2  60             rts
00A103  2               
00A103  2               _initfailed:
00A103  2  C8             iny
00A104  2  C0 02          cpy #2
00A106  2  D0 95          bne _initretry
00A108  2  A9 58          lda #'X'
00A10A  2  20 8D A8       jsr print_char
00A10D  2               _loop:
00A10D  2  4C 0D A1       jmp _loop
00A110  2               
00A110  2               
00A110  2               sd_cmd0_bytes:
00A110  2  40 00 00 00    .byte $40, $00, $00, $00, $00, $95
00A114  2  00 95        
00A116  2               sd_cmd8_bytes:
00A116  2  48 00 00 01    .byte $48, $00, $00, $01, $aa, $87
00A11A  2  AA 87        
00A11C  2               sd_cmd55_bytes:
00A11C  2  77 00 00 00    .byte $77, $00, $00, $00, $00, $01
00A120  2  00 01        
00A122  2               sd_cmd41_bytes:
00A122  2  69 40 00 00    .byte $69, $40, $00, $00, $00, $01
00A126  2  00 01        
00A128  2               
00A128  2               
00A128  2               
00A128  2               sd_readbyte:
00A128  2                 ; Enable the card and tick the clock 8 times with MOSI high,
00A128  2                 ; capturing bits from MISO and returning them
00A128  2               
00A128  2  A2 FE          ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
00A12A  2               
00A12A  2               _rbloop:
00A12A  2               
00A12A  2  A9 04          lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
00A12C  2  8D 00 17       sta PORTA
00A12F  2               
00A12F  2  A9 0C          lda #SD_MOSI | SD_SCK       ; toggle the clock high
00A131  2  8D 00 17       sta PORTA
00A134  2               
00A134  2  AD 00 17       lda PORTA                   ; read next bit
00A137  2  29 02          and #SD_MISO
00A139  2               
00A139  2  18             clc                         ; default to clearing the bottom bit
00A13A  2  F0 01          beq _bitnotset              ; unless MISO was set
00A13C  2  38             sec                         ; in which case get ready to set the bottom bit
00A13D  2               _bitnotset:
00A13D  2               
00A13D  2  8A             txa                         ; transfer partial result from X
00A13E  2  2A             rol                         ; rotate carry bit into read result, and loop bit into carry
00A13F  2  AA             tax                         ; save partial result back to X
00A140  2               
00A140  2  B0 E8          bcs _rbloop                   ; loop if we need to read more bits
00A142  2               
00A142  2  60             rts
00A143  2               
00A143  2               
00A143  2               sd_writebyte:
00A143  2                 ; Tick the clock 8 times with descending bits on MOSI
00A143  2                 ; SD communication is mostly half-duplex so we ignore anything it sends back here
00A143  2               
00A143  2  A2 08          ldx #8                      ; send 8 bits
00A145  2               
00A145  2               _wbloop:
00A145  2  0A             asl                         ; shift next bit into carry
00A146  2  A8             tay                         ; save remaining bits for later
00A147  2               
00A147  2  A9 00          lda #0
00A149  2  90 02          bcc _sendbit                ; if carry clear, don't set MOSI for this bit
00A14B  2  09 04          ora #SD_MOSI
00A14D  2               
00A14D  2               _sendbit:
00A14D  2  8D 00 17       sta PORTA                   ; set MOSI (or not) first with SCK low
00A150  2  49 08          eor #SD_SCK
00A152  2  8D 00 17       sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
00A155  2               
00A155  2  98             tya                         ; restore remaining bits to send
00A156  2               
00A156  2  CA             dex
00A157  2  D0 EC          bne _wbloop                   ; loop if there are more bits to send
00A159  2               
00A159  2  60             rts
00A15A  2               
00A15A  2               
00A15A  2               sd_waitresult:
00A15A  2                 ; Wait for the SD card to return something other than $ff
00A15A  2  20 28 A1       jsr sd_readbyte
00A15D  2  C9 FF          cmp #$ff
00A15F  2  F0 F9          beq sd_waitresult
00A161  2  60             rts
00A162  2               
00A162  2               
00A162  2               sd_sendcommand:
00A162  2                 ; Debug print which command is being executed
00A162  2                 ; lda #'c'
00A162  2                 ; jsr print_char
00A162  2                 ; ldx #0
00A162  2                 ; lda (zp_sd_address,x)
00A162  2                 ; jsr print_hex
00A162  2               
00A162  2  A9 04          lda #SD_MOSI           ; pull CS low to begin command
00A164  2  8D 00 17       sta PORTA
00A167  2               
00A167  2  A0 00          ldy #0
00A169  2  B1 40          lda (zp_sd_address),y    ; command byte
00A16B  2  20 43 A1       jsr sd_writebyte
00A16E  2  A0 01          ldy #1
00A170  2  B1 40          lda (zp_sd_address),y    ; data 1
00A172  2  20 43 A1       jsr sd_writebyte
00A175  2  A0 02          ldy #2
00A177  2  B1 40          lda (zp_sd_address),y    ; data 2
00A179  2  20 43 A1       jsr sd_writebyte
00A17C  2  A0 03          ldy #3
00A17E  2  B1 40          lda (zp_sd_address),y    ; data 3
00A180  2  20 43 A1       jsr sd_writebyte
00A183  2  A0 04          ldy #4
00A185  2  B1 40          lda (zp_sd_address),y    ; data 4
00A187  2  20 43 A1       jsr sd_writebyte
00A18A  2  A0 05          ldy #5
00A18C  2  B1 40          lda (zp_sd_address),y    ; crc
00A18E  2  20 43 A1       jsr sd_writebyte
00A191  2               
00A191  2  20 5A A1       jsr sd_waitresult
00A194  2  48             pha
00A195  2               
00A195  2                 ; Debug print the result code
00A195  2                 ; jsr print_hex
00A195  2               
00A195  2                 ; End command
00A195  2  A9 14          lda #SD_CS | SD_MOSI   ; set CS high again
00A197  2  8D 00 17       sta PORTA
00A19A  2               
00A19A  2  68             pla   ; restore result code
00A19B  2  60             rts
00A19C  2               
00A19C  2               
00A19C  2               sd_readsector:
00A19C  2                 ; Read a sector from the SD card.  A sector is 512 bytes.
00A19C  2                 ;
00A19C  2                 ; Parameters:
00A19C  2                 ;    zp_sd_currentsector   32-bit sector number
00A19C  2                 ;    zp_sd_address     address of buffer to receive data
00A19C  2               
00A19C  2  A9 04          lda #SD_MOSI
00A19E  2  8D 00 17       sta PORTA
00A1A1  2               
00A1A1  2                 ; Command 17, arg is sector number, crc not checked
00A1A1  2  A9 51          lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
00A1A3  2  20 43 A1       jsr sd_writebyte
00A1A6  2  A5 45          lda zp_sd_currentsector+3   ; sector 24:31
00A1A8  2  20 43 A1       jsr sd_writebyte
00A1AB  2  A5 44          lda zp_sd_currentsector+2   ; sector 16:23
00A1AD  2  20 43 A1       jsr sd_writebyte
00A1B0  2  A5 43          lda zp_sd_currentsector+1   ; sector 8:15
00A1B2  2  20 43 A1       jsr sd_writebyte
00A1B5  2  A5 42          lda zp_sd_currentsector     ; sector 0:7
00A1B7  2  20 43 A1       jsr sd_writebyte
00A1BA  2  A9 01          lda #$01                    ; crc (not checked)
00A1BC  2  20 43 A1       jsr sd_writebyte
00A1BF  2               
00A1BF  2  20 5A A1       jsr sd_waitresult
00A1C2  2  C9 00          cmp #$00
00A1C4  2  D0 22          bne _libsdfail
00A1C6  2               
00A1C6  2                 ; wait for data
00A1C6  2  20 5A A1       jsr sd_waitresult
00A1C9  2  C9 FE          cmp #$fe
00A1CB  2  D0 1B          bne _libsdfail
00A1CD  2               
00A1CD  2                 ; Need to read 512 bytes - two pages of 256 bytes each
00A1CD  2  20 DD A1       jsr _readpage
00A1D0  2  E6 41          inc zp_sd_address+1
00A1D2  2  20 DD A1       jsr _readpage
00A1D5  2  C6 41          dec zp_sd_address+1
00A1D7  2               
00A1D7  2                 ; End command
00A1D7  2  A9 14          lda #SD_CS | SD_MOSI
00A1D9  2  8D 00 17       sta PORTA
00A1DC  2               
00A1DC  2  60             rts
00A1DD  2               
00A1DD  2               _readpage:
00A1DD  2                 ; Read 256 bytes to the address at zp_sd_address
00A1DD  2  A0 00          ldy #0
00A1DF  2               _readpageloop:
00A1DF  2  20 28 A1       jsr sd_readbyte
00A1E2  2  91 40          sta (zp_sd_address),y
00A1E4  2  C8             iny
00A1E5  2  D0 F8          bne _readpageloop
00A1E7  2  60             rts
00A1E8  2               
00A1E8  2               _libsdfail:
00A1E8  2  A9 73          lda #'s'
00A1EA  2  20 8D A8       jsr print_char
00A1ED  2  A9 3A          lda #':'
00A1EF  2  20 8D A8       jsr print_char
00A1F2  2  A9 66          lda #'f'
00A1F4  2  20 8D A8       jsr print_char
00A1F7  2               _libsdfailloop:
00A1F7  2  4C F7 A1       jmp _libsdfailloop
00A1FA  2               
00A1FA  2               sd_writesector:
00A1FA  2                 ; Write a sector to the SD card.  A sector is 512 bytes.
00A1FA  2                 ;
00A1FA  2                 ; Parameters:
00A1FA  2                 ;    zp_sd_currentsector   32-bit sector number
00A1FA  2                 ;    zp_sd_address     address of buffer to take data from
00A1FA  2               
00A1FA  2  A9 04          lda #SD_MOSI
00A1FC  2  8D 00 17       sta PORTA
00A1FF  2               
00A1FF  2                 ; Command 24, arg is sector number, crc not checked
00A1FF  2  A9 58          lda #$58                    ; CMD24 - WRITE_BLOCK
00A201  2  20 43 A1       jsr sd_writebyte
00A204  2  A5 45          lda zp_sd_currentsector+3   ; sector 24:31
00A206  2  20 43 A1       jsr sd_writebyte
00A209  2  A5 44          lda zp_sd_currentsector+2   ; sector 16:23
00A20B  2  20 43 A1       jsr sd_writebyte
00A20E  2  A5 43          lda zp_sd_currentsector+1   ; sector 8:15
00A210  2  20 43 A1       jsr sd_writebyte
00A213  2  A5 42          lda zp_sd_currentsector     ; sector 0:7
00A215  2  20 43 A1       jsr sd_writebyte
00A218  2  A9 01          lda #$01                    ; crc (not checked)
00A21A  2  20 43 A1       jsr sd_writebyte
00A21D  2               
00A21D  2  20 5A A1       jsr sd_waitresult
00A220  2  C9 00          cmp #$00
00A222  2  D0 C4          bne _libsdfail
00A224  2               
00A224  2                 ; Send start token
00A224  2  A9 FE          lda #$fe
00A226  2  20 43 A1       jsr sd_writebyte
00A229  2               
00A229  2                 ; Need to write 512 bytes - two pages of 256 bytes each
00A229  2  20 49 A2       jsr _writepage
00A22C  2  E6 41          inc zp_sd_address+1
00A22E  2  20 49 A2       jsr _writepage
00A231  2  C6 41          dec zp_sd_address+1
00A233  2               
00A233  2                 ; wait for data response
00A233  2  20 5A A1       jsr sd_waitresult
00A236  2  29 1F          and #$1f
00A238  2  C9 05          cmp #$05
00A23A  2  D0 AC          bne _libsdfail
00A23C  2               
00A23C  2               _waitidle:
00A23C  2  20 28 A1       jsr sd_readbyte
00A23F  2  C9 FF          cmp #$ff
00A241  2  D0 F9          bne _waitidle
00A243  2               
00A243  2                 ; End command
00A243  2  A9 14          lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
00A245  2  8D 00 17       sta PORTA
00A248  2               
00A248  2  60             rts
00A249  2               
00A249  2               _writepage:
00A249  2                 ; Write 256 bytes fom zp_sd_address
00A249  2  A0 00          ldy #0
00A24B  2               _writeloop:
00A24B  2  B1 40          lda (zp_sd_address),y
00A24D  2  98             tya
00A24E  2  48             pha
00A24F  2  20 43 A1       jsr sd_writebyte
00A252  2  68             pla
00A253  2  A8             tay
00A254  2  C8             iny
00A255  2  D0 F4          bne _writeloop
00A257  2  60             rts
00A258  2               
00A258  1                 .include "libfat32.s"
00A258  2               ; FAT32/SD interface library
00A258  2               ;
00A258  2               ; This module requires some RAM workspace to be defined elsewhere:
00A258  2               ;
00A258  2               ; fat32_workspace    - a large page-aligned 512-byte workspace
00A258  2               ; zp_fat32_variables - 49 bytes of zero-page storage for variables etc
00A258  2               
00A258  2               fat32_readbuffer = fat32_workspace
00A258  2               
00A258  2               
00A258  2               fat32_fatstart                  = zp_fat32_variables + $00  ; 4 bytes
00A258  2               fat32_datastart                 = zp_fat32_variables + $04  ; 4 bytes
00A258  2               fat32_rootcluster               = zp_fat32_variables + $08  ; 4 bytes
00A258  2               fat32_sectorspercluster         = zp_fat32_variables + $0c  ; 1 byte
00A258  2               fat32_pendingsectors            = zp_fat32_variables + $0d  ; 1 byte
00A258  2               fat32_address                   = zp_fat32_variables + $0e  ; 2 bytes
00A258  2               fat32_nextcluster               = zp_fat32_variables + $10  ; 4 bytes
00A258  2               fat32_bytesremaining            = zp_fat32_variables + $14  ; 4 bytes
00A258  2               fat32_lastfoundfreecluster      = zp_fat32_variables + $18  ; 4 bytes
00A258  2               fat32_lastcluster               = zp_fat32_variables + $1c  ; 4 bytes
00A258  2               fat32_lastsector                = zp_fat32_variables + $21  ; 4 bytes
00A258  2               fat32_filenamepointer           = zp_fat32_variables + $26  ; 2 bytes
00A258  2               fat32_numfats                   = zp_fat32_variables + $28  ; 1 byte
00A258  2               fat32_filecluster               = zp_fat32_variables + $29  ; 4 bytes
00A258  2               fat32_sectorsperfat             = zp_fat32_variables + $2d  ; 4 bytes
00A258  2               
00A258  2               fat32_errorstage            = fat32_bytesremaining  ; only used during initialization
00A258  2               
00A258  2               fat32_init:
00A258  2                 ; Initialize the module - read the MBR etc, find the partition,
00A258  2                 ; and set up the variables ready for navigating the filesystem
00A258  2               
00A258  2                 ; Read the MBR and extract pertinent information
00A258  2               
00A258  2  A9 00          lda #0
00A25A  2  85 5A          sta fat32_errorstage
00A25C  2               
00A25C  2                 ; Sector 0
00A25C  2  A9 00          lda #0
00A25E  2  85 42          sta zp_sd_currentsector
00A260  2  85 43          sta zp_sd_currentsector+1
00A262  2  85 44          sta zp_sd_currentsector+2
00A264  2  85 45          sta zp_sd_currentsector+3
00A266  2               
00A266  2                 ; Target buffer
00A266  2  A9 00          lda #<fat32_readbuffer
00A268  2  85 40          sta zp_sd_address
00A26A  2  A9 02          lda #>fat32_readbuffer
00A26C  2  85 41          sta zp_sd_address+1
00A26E  2               
00A26E  2                 ; Do the read
00A26E  2  20 9C A1       jsr sd_readsector
00A271  2               
00A271  2               
00A271  2  E6 5A          inc fat32_errorstage ; stage 1 = boot sector signature check
00A273  2               
00A273  2                 ; Check some things
00A273  2  AD FE 03       lda fat32_readbuffer+510 ; Boot sector signature 55
00A276  2  C9 55          cmp #$55
00A278  2  D0 2D          bne _fail
00A27A  2  AD FF 03       lda fat32_readbuffer+511 ; Boot sector signature aa
00A27D  2  C9 AA          cmp #$aa
00A27F  2  D0 26          bne _fail
00A281  2               
00A281  2               
00A281  2  E6 5A          inc fat32_errorstage ; stage 2 = finding partition
00A283  2               
00A283  2                 ; Find a FAT32 partition
00A283  2                 ; 11 (0xb)  W95 FAT32
00A283  2                 ; 12 (0xc)  W95 FAT32 (LBA)
00A283  2                 ; 13 (0xe)  W95 FAT16 (LBA)
00A283  2                 ; 14 (0xf)  W95 Ext'd (LBA)
00A283  2               _FSTYPE_FAT32 = 12
00A283  2  A2 00          ldx #0
00A285  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00A288  2  C9 0C          cmp #_FSTYPE_FAT32
00A28A  2  F0 1E          beq _foundpart
00A28C  2  A2 10          ldx #16
00A28E  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00A291  2  C9 0C          cmp #_FSTYPE_FAT32
00A293  2  F0 15          beq _foundpart
00A295  2  A2 20          ldx #32
00A297  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00A29A  2  C9 0C          cmp #_FSTYPE_FAT32
00A29C  2  F0 0C          beq _foundpart
00A29E  2  A2 30          ldx #48
00A2A0  2  BD C2 03       lda fat32_readbuffer+$1c2,x
00A2A3  2  C9 0C          cmp #_FSTYPE_FAT32
00A2A5  2  F0 03          beq _foundpart
00A2A7  2               
00A2A7  2               _fail:
00A2A7  2  4C 84 A3       jmp _error
00A2AA  2               
00A2AA  2               _foundpart:
00A2AA  2               
00A2AA  2                 ; Read the FAT32 BPB
00A2AA  2  BD C6 03       lda fat32_readbuffer+$1c6,x
00A2AD  2  85 42          sta zp_sd_currentsector
00A2AF  2  BD C7 03       lda fat32_readbuffer+$1c7,x
00A2B2  2  85 43          sta zp_sd_currentsector+1
00A2B4  2  BD C8 03       lda fat32_readbuffer+$1c8,x
00A2B7  2  85 44          sta zp_sd_currentsector+2
00A2B9  2  BD C9 03       lda fat32_readbuffer+$1c9,x
00A2BC  2  85 45          sta zp_sd_currentsector+3
00A2BE  2               
00A2BE  2  20 9C A1       jsr sd_readsector
00A2C1  2               
00A2C1  2               
00A2C1  2  E6 5A          inc fat32_errorstage ; stage 3 = BPB signature check
00A2C3  2               
00A2C3  2                 ; Check some things
00A2C3  2  AD FE 03       lda fat32_readbuffer+510 ; BPB sector signature 55
00A2C6  2  C9 55          cmp #$55
00A2C8  2  D0 DD          bne _fail
00A2CA  2  AD FF 03       lda fat32_readbuffer+511 ; BPB sector signature aa
00A2CD  2  C9 AA          cmp #$aa
00A2CF  2  D0 D6          bne _fail
00A2D1  2               
00A2D1  2  E6 5A          inc fat32_errorstage ; stage 4 = RootEntCnt check
00A2D3  2               
00A2D3  2  AD 11 02       lda fat32_readbuffer+17 ; RootEntCnt should be 0 for FAT32
00A2D6  2  0D 12 02       ora fat32_readbuffer+18
00A2D9  2  D0 CC          bne _fail
00A2DB  2               
00A2DB  2  E6 5A          inc fat32_errorstage ; stage 5 = TotSec16 check
00A2DD  2               
00A2DD  2  AD 13 02       lda fat32_readbuffer+19 ; TotSec16 should be 0 for FAT32
00A2E0  2  0D 14 02       ora fat32_readbuffer+20
00A2E3  2  D0 C2          bne _fail
00A2E5  2               
00A2E5  2  E6 5A          inc fat32_errorstage ; stage 6 = SectorsPerCluster check
00A2E7  2               
00A2E7  2                 ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
00A2E7  2  AD 0B 02       lda fat32_readbuffer+11 ; low byte should be zero
00A2EA  2  D0 BB          bne _fail
00A2EC  2  AD 0C 02       lda fat32_readbuffer+12 ; high byte is 2 (512), 4, 8, or 16
00A2EF  2  C9 02          cmp #2
00A2F1  2  D0 B4          bne _fail
00A2F3  2               
00A2F3  2               
00A2F3  2                 ; Calculate the starting sector of the FAT
00A2F3  2  18             clc
00A2F4  2  A5 42          lda zp_sd_currentsector
00A2F6  2  6D 0E 02       adc fat32_readbuffer+14    ; reserved sectors lo
00A2F9  2  85 46          sta fat32_fatstart
00A2FB  2  85 4A          sta fat32_datastart
00A2FD  2  A5 43          lda zp_sd_currentsector+1
00A2FF  2  6D 0F 02       adc fat32_readbuffer+15    ; reserved sectors hi
00A302  2  85 47          sta fat32_fatstart+1
00A304  2  85 4B          sta fat32_datastart+1
00A306  2  A5 44          lda zp_sd_currentsector+2
00A308  2  69 00          adc #0
00A30A  2  85 48          sta fat32_fatstart+2
00A30C  2  85 4C          sta fat32_datastart+2
00A30E  2  A5 45          lda zp_sd_currentsector+3
00A310  2  69 00          adc #0
00A312  2  85 49          sta fat32_fatstart+3
00A314  2  85 4D          sta fat32_datastart+3
00A316  2               
00A316  2                 ; Calculate the starting sector of the data area
00A316  2  AE 10 02       ldx fat32_readbuffer+16   ; number of FATs
00A319  2  86 6E          stx fat32_numfats         ; (stash for later as well)
00A31B  2               _skipfatsloop:
00A31B  2  18             clc
00A31C  2  A5 4A          lda fat32_datastart
00A31E  2  6D 24 02       adc fat32_readbuffer+36 ; fatsize 0
00A321  2  85 4A          sta fat32_datastart
00A323  2  A5 4B          lda fat32_datastart+1
00A325  2  6D 25 02       adc fat32_readbuffer+37 ; fatsize 1
00A328  2  85 4B          sta fat32_datastart+1
00A32A  2  A5 4C          lda fat32_datastart+2
00A32C  2  6D 26 02       adc fat32_readbuffer+38 ; fatsize 2
00A32F  2  85 4C          sta fat32_datastart+2
00A331  2  A5 4D          lda fat32_datastart+3
00A333  2  6D 27 02       adc fat32_readbuffer+39 ; fatsize 3
00A336  2  85 4D          sta fat32_datastart+3
00A338  2  CA             dex
00A339  2  D0 E0          bne _skipfatsloop
00A33B  2               
00A33B  2                 ; Sectors-per-cluster is a power of two from 1 to 128
00A33B  2  AD 0D 02       lda fat32_readbuffer+13
00A33E  2  85 52          sta fat32_sectorspercluster
00A340  2               
00A340  2                 ; Remember the root cluster
00A340  2  AD 2C 02       lda fat32_readbuffer+44
00A343  2  85 4E          sta fat32_rootcluster
00A345  2  AD 2D 02       lda fat32_readbuffer+45
00A348  2  85 4F          sta fat32_rootcluster+1
00A34A  2  AD 2E 02       lda fat32_readbuffer+46
00A34D  2  85 50          sta fat32_rootcluster+2
00A34F  2  AD 2F 02       lda fat32_readbuffer+47
00A352  2  85 51          sta fat32_rootcluster+3
00A354  2               
00A354  2                 ; Save Sectors Per FAT
00A354  2  AD 24 02       lda fat32_readbuffer+36
00A357  2  85 73          sta fat32_sectorsperfat
00A359  2  AD 25 02       lda fat32_readbuffer+37
00A35C  2  85 74          sta fat32_sectorsperfat+1
00A35E  2  AD 26 02       lda fat32_readbuffer+38
00A361  2  85 75          sta fat32_sectorsperfat+2
00A363  2  AD 27 02       lda fat32_readbuffer+39
00A366  2  85 76          sta fat32_sectorsperfat+3
00A368  2               
00A368  2                 ; Set the last found free cluster to 0.
00A368  2  A9 00          lda #0
00A36A  2  85 5E          sta fat32_lastfoundfreecluster
00A36C  2  85 5F          sta fat32_lastfoundfreecluster+1
00A36E  2  85 60          sta fat32_lastfoundfreecluster+2
00A370  2  85 61          sta fat32_lastfoundfreecluster+3
00A372  2               
00A372  2                 ; As well as the last read clusters and sectors
00A372  2  85 62          sta fat32_lastcluster
00A374  2  85 63          sta fat32_lastcluster+1
00A376  2  85 64          sta fat32_lastcluster+2
00A378  2  85 65          sta fat32_lastcluster+3
00A37A  2  85 67          sta fat32_lastsector
00A37C  2  85 68          sta fat32_lastsector+1
00A37E  2  85 69          sta fat32_lastsector+2
00A380  2  85 6A          sta fat32_lastsector+3
00A382  2               
00A382  2  18             clc
00A383  2  60             rts
00A384  2               
00A384  2               _error:
00A384  2  38             sec
00A385  2  60             rts
00A386  2               
00A386  2               
00A386  2               fat32_seekcluster:
00A386  2               ; Calculates the FAT sector given fat32_nextcluster and stores in zp_sd_currentsector
00A386  2               ; Optionally will load the 512 byte FAT sector into memory at fat32_readbuffer
00A386  2               ; If carry is set, subroutine is optimized to skip the loading if the expected
00A386  2               ; sector is already loaded. Clearing carry before calling will skip optimization
00A386  2               ; and force reload of the FAT sector. Once the FAT sector is loaded,
00A386  2               ; the next cluster in the chain is loaded into fat32_nextcluster and
00A386  2               ; zp_sd_currentsector is updated to point to the referenced data sector
00A386  2               
00A386  2  08             php
00A387  2               
00A387  2                 ; Target buffer
00A387  2  A9 00          lda #<fat32_readbuffer
00A389  2  85 40          sta zp_sd_address
00A38B  2  A9 02          lda #>fat32_readbuffer
00A38D  2  85 41          sta zp_sd_address+1
00A38F  2               
00A38F  2                 ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
00A38F  2  A5 56          lda fat32_nextcluster
00A391  2  0A             asl
00A392  2  A5 57          lda fat32_nextcluster+1
00A394  2  2A             rol
00A395  2  85 42          sta zp_sd_currentsector
00A397  2  A5 58          lda fat32_nextcluster+2
00A399  2  2A             rol
00A39A  2  85 43          sta zp_sd_currentsector+1
00A39C  2  A5 59          lda fat32_nextcluster+3
00A39E  2  2A             rol
00A39F  2  85 44          sta zp_sd_currentsector+2
00A3A1  2                 ; note: cluster numbers never have the top bit set, so no carry can occur
00A3A1  2               
00A3A1  2                 ; Add FAT starting sector
00A3A1  2  A5 42          lda zp_sd_currentsector
00A3A3  2  65 46          adc fat32_fatstart
00A3A5  2  85 42          sta zp_sd_currentsector
00A3A7  2  A5 43          lda zp_sd_currentsector+1
00A3A9  2  65 47          adc fat32_fatstart+1
00A3AB  2  85 43          sta zp_sd_currentsector+1
00A3AD  2  A5 44          lda zp_sd_currentsector+2
00A3AF  2  65 48          adc fat32_fatstart+2
00A3B1  2  85 44          sta zp_sd_currentsector+2
00A3B3  2  A9 00          lda #0
00A3B5  2  65 49          adc fat32_fatstart+3
00A3B7  2  85 45          sta zp_sd_currentsector+3
00A3B9  2               
00A3B9  2                 ; Branch if we don't need to check
00A3B9  2  28             plp
00A3BA  2  90 18          bcc _newsector
00A3BC  2               
00A3BC  2                 ; Check if this sector is the same as the last one
00A3BC  2  A5 67          lda fat32_lastsector
00A3BE  2  C5 42          cmp zp_sd_currentsector
00A3C0  2  D0 12          bne _newsector
00A3C2  2  A5 68          lda fat32_lastsector+1
00A3C4  2  C5 43          cmp zp_sd_currentsector+1
00A3C6  2  D0 0C          bne _newsector
00A3C8  2  A5 69          lda fat32_lastsector+2
00A3CA  2  C5 44          cmp zp_sd_currentsector+2
00A3CC  2  D0 06          bne _newsector
00A3CE  2  A5 6A          lda fat32_lastsector+3
00A3D0  2  C5 45          cmp zp_sd_currentsector+3
00A3D2  2  F0 13          beq _notnew
00A3D4  2               
00A3D4  2               _newsector:
00A3D4  2               
00A3D4  2                 ; Read the sector from the FAT
00A3D4  2  20 9C A1       jsr sd_readsector
00A3D7  2               
00A3D7  2                 ; Update fat32_lastsector
00A3D7  2               
00A3D7  2  A5 42          lda zp_sd_currentsector
00A3D9  2  85 67          sta fat32_lastsector
00A3DB  2  A5 43          lda zp_sd_currentsector+1
00A3DD  2  85 68          sta fat32_lastsector+1
00A3DF  2  A5 44          lda zp_sd_currentsector+2
00A3E1  2  85 69          sta fat32_lastsector+2
00A3E3  2  A5 45          lda zp_sd_currentsector+3
00A3E5  2  85 6A          sta fat32_lastsector+3
00A3E7  2               
00A3E7  2               _notnew:
00A3E7  2               
00A3E7  2                 ; Before using this FAT data, set currentsector ready to read the cluster itself
00A3E7  2                 ; We need to multiply the cluster number minus two by the number of sectors per
00A3E7  2                 ; cluster, then add the data region start sector
00A3E7  2               
00A3E7  2                 ; Subtract two from cluster number
00A3E7  2  38             sec
00A3E8  2  A5 56          lda fat32_nextcluster
00A3EA  2  E9 02          sbc #2
00A3EC  2  85 42          sta zp_sd_currentsector
00A3EE  2  A5 57          lda fat32_nextcluster+1
00A3F0  2  E9 00          sbc #0
00A3F2  2  85 43          sta zp_sd_currentsector+1
00A3F4  2  A5 58          lda fat32_nextcluster+2
00A3F6  2  E9 00          sbc #0
00A3F8  2  85 44          sta zp_sd_currentsector+2
00A3FA  2  A5 59          lda fat32_nextcluster+3
00A3FC  2  E9 00          sbc #0
00A3FE  2  85 45          sta zp_sd_currentsector+3
00A400  2               
00A400  2                 ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
00A400  2  A5 52          lda fat32_sectorspercluster
00A402  2               _spcshiftloop:
00A402  2  4A             lsr
00A403  2  B0 0B          bcs _spcshiftloopdone
00A405  2  06 42          asl zp_sd_currentsector
00A407  2  26 43          rol zp_sd_currentsector+1
00A409  2  26 44          rol zp_sd_currentsector+2
00A40B  2  26 45          rol zp_sd_currentsector+3
00A40D  2  4C 02 A4       jmp _spcshiftloop
00A410  2               _spcshiftloopdone:
00A410  2               
00A410  2                 ; Add the data region start sector
00A410  2  18             clc
00A411  2  A5 42          lda zp_sd_currentsector
00A413  2  65 4A          adc fat32_datastart
00A415  2  85 42          sta zp_sd_currentsector
00A417  2  A5 43          lda zp_sd_currentsector+1
00A419  2  65 4B          adc fat32_datastart+1
00A41B  2  85 43          sta zp_sd_currentsector+1
00A41D  2  A5 44          lda zp_sd_currentsector+2
00A41F  2  65 4C          adc fat32_datastart+2
00A421  2  85 44          sta zp_sd_currentsector+2
00A423  2  A5 45          lda zp_sd_currentsector+3
00A425  2  65 4D          adc fat32_datastart+3
00A427  2  85 45          sta zp_sd_currentsector+3
00A429  2               
00A429  2                 ; That's now ready for later code to read this sector in - tell it how many consecutive
00A429  2                 ; sectors it can now read
00A429  2  A5 52          lda fat32_sectorspercluster
00A42B  2  85 53          sta fat32_pendingsectors
00A42D  2               
00A42D  2                 ; Now go back to looking up the next cluster in the chain
00A42D  2                 ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
00A42D  2               
00A42D  2                 ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
00A42D  2  A5 56          lda fat32_nextcluster
00A42F  2  29 7F          and #$7f
00A431  2  0A             asl
00A432  2  0A             asl
00A433  2  A8             tay ; Y = low byte of offset
00A434  2               
00A434  2                 ; Add the potentially carried bit to the high byte of the address
00A434  2  A5 41          lda zp_sd_address+1
00A436  2  69 00          adc #0
00A438  2  85 41          sta zp_sd_address+1
00A43A  2               
00A43A  2                 ; Copy out the next cluster in the chain for later use
00A43A  2  B1 40          lda (zp_sd_address),y
00A43C  2  85 56          sta fat32_nextcluster
00A43E  2  C8             iny
00A43F  2  B1 40          lda (zp_sd_address),y
00A441  2  85 57          sta fat32_nextcluster+1
00A443  2  C8             iny
00A444  2  B1 40          lda (zp_sd_address),y
00A446  2  85 58          sta fat32_nextcluster+2
00A448  2  C8             iny
00A449  2  B1 40          lda (zp_sd_address),y
00A44B  2  29 0F          and #$0f
00A44D  2  85 59          sta fat32_nextcluster+3
00A44F  2               
00A44F  2                 ; See if it's the end of the chain
00A44F  2  09 F0          ora #$f0
00A451  2  25 58          and fat32_nextcluster+2
00A453  2  25 57          and fat32_nextcluster+1
00A455  2  C9 FF          cmp #$ff
00A457  2  D0 08          bne _notendofchain
00A459  2  A5 56          lda fat32_nextcluster
00A45B  2  C9 F8          cmp #$f8
00A45D  2  90 02          bcc _notendofchain
00A45F  2               
00A45F  2                 ; It's the end of the chain, set the top bits so that we can tell this later on
00A45F  2  85 59          sta fat32_nextcluster+3
00A461  2               _notendofchain:
00A461  2               
00A461  2  60             rts
00A462  2               
00A462  2               
00A462  2               fat32_readnextsector:
00A462  2                 ; Reads the next sector from a cluster chain into the buffer at fat32_address.
00A462  2                 ;
00A462  2                 ; Advances the current sector ready for the next read and looks up the next cluster
00A462  2                 ; in the chain when necessary.
00A462  2                 ;
00A462  2                 ; On return, carry is clear if data was read, or set if the cluster chain has ended.
00A462  2               
00A462  2                 ; Maybe there are pending sectors in the current cluster
00A462  2  A5 53          lda fat32_pendingsectors
00A464  2  D0 08          bne _readsector
00A466  2               
00A466  2                 ; No pending sectors, check for end of cluster chain
00A466  2  A5 59          lda fat32_nextcluster+3
00A468  2  30 21          bmi _readendofchain
00A46A  2               
00A46A  2                 ; Prepare to read the next cluster
00A46A  2  38             sec
00A46B  2  20 86 A3       jsr fat32_seekcluster
00A46E  2               
00A46E  2               _readsector:
00A46E  2  C6 53          dec fat32_pendingsectors
00A470  2               
00A470  2                 ; Set up target address
00A470  2  A5 54          lda fat32_address
00A472  2  85 40          sta zp_sd_address
00A474  2  A5 55          lda fat32_address+1
00A476  2  85 41          sta zp_sd_address+1
00A478  2               
00A478  2                 ; Read the sector
00A478  2  20 9C A1       jsr sd_readsector
00A47B  2               
00A47B  2                 ; Advance to next sector
00A47B  2  E6 42          inc zp_sd_currentsector
00A47D  2  D0 0A          bne _sectorincrementdone
00A47F  2  E6 43          inc zp_sd_currentsector+1
00A481  2  D0 06          bne _sectorincrementdone
00A483  2  E6 44          inc zp_sd_currentsector+2
00A485  2  D0 02          bne _sectorincrementdone
00A487  2  E6 45          inc zp_sd_currentsector+3
00A489  2               _sectorincrementdone:
00A489  2               
00A489  2                 ; Success - clear carry and return
00A489  2  18             clc
00A48A  2  60             rts
00A48B  2               
00A48B  2               _readendofchain:
00A48B  2                 ; End of chain - set carry and return
00A48B  2  38             sec
00A48C  2  60             rts
00A48D  2               
00A48D  2               fat32_writenextsector:
00A48D  2                 ; Writes the next sector in a cluster chain from the buffer at fat32_address.
00A48D  2                 ;
00A48D  2                 ; On return, carry is set if its the end of the chain.
00A48D  2               
00A48D  2                 ; Maybe there are pending sectors in the current cluster
00A48D  2  A5 53          lda fat32_pendingsectors
00A48F  2  D0 08          bne _beginwrite
00A491  2               
00A491  2                 ; No pending sectors, check for end of cluster chain
00A491  2  A5 59          lda fat32_nextcluster+3
00A493  2  30 09          bmi _writeendofchain
00A495  2               
00A495  2                 ; Prepare to read the next cluster
00A495  2  38             sec
00A496  2  20 86 A3       jsr fat32_seekcluster
00A499  2               
00A499  2               _beginwrite:
00A499  2  20 A3 A4       jsr _writesector
00A49C  2               
00A49C  2                 ; Success - clear carry and return
00A49C  2  18             clc
00A49D  2  60             rts
00A49E  2               
00A49E  2               _writeendofchain:
00A49E  2                 ; End of chain - set carry, write a sector, and return
00A49E  2  20 A3 A4       jsr _writesector
00A4A1  2  38             sec
00A4A2  2  60             rts
00A4A3  2               
00A4A3  2               _writesector:
00A4A3  2  C6 53          dec fat32_pendingsectors
00A4A5  2               
00A4A5  2                 ; Set up target address
00A4A5  2  A5 54          lda fat32_address
00A4A7  2  85 40          sta zp_sd_address
00A4A9  2  A5 55          lda fat32_address+1
00A4AB  2  85 41          sta zp_sd_address+1
00A4AD  2               
00A4AD  2                 ; Write the sector
00A4AD  2  20 FA A1       jsr sd_writesector
00A4B0  2               
00A4B0  2                 ; Advance to next sector
00A4B0  2  E6 42          inc zp_sd_currentsector
00A4B2  2  D0 0A          bne _nextsectorincrementdone
00A4B4  2  E6 43          inc zp_sd_currentsector+1
00A4B6  2  D0 06          bne _nextsectorincrementdone
00A4B8  2  E6 44          inc zp_sd_currentsector+2
00A4BA  2  D0 02          bne _nextsectorincrementdone
00A4BC  2  E6 45          inc zp_sd_currentsector+3
00A4BE  2               _nextsectorincrementdone:
00A4BE  2  60             rts
00A4BF  2               
00A4BF  2               fat32_updatefat:
00A4BF  2                ; Preserve the current sector
00A4BF  2  A5 42          lda zp_sd_currentsector
00A4C1  2  48             pha
00A4C2  2  A5 43          lda zp_sd_currentsector+1
00A4C4  2  48             pha
00A4C5  2  A5 44          lda zp_sd_currentsector+2
00A4C7  2  48             pha
00A4C8  2  A5 45          lda zp_sd_currentsector+3
00A4CA  2  48             pha
00A4CB  2               
00A4CB  2                 ; Write FAT sector
00A4CB  2  A5 67          lda fat32_lastsector
00A4CD  2  85 42          sta zp_sd_currentsector
00A4CF  2  A5 68          lda fat32_lastsector+1
00A4D1  2  85 43          sta zp_sd_currentsector+1
00A4D3  2  A5 69          lda fat32_lastsector+2
00A4D5  2  85 44          sta zp_sd_currentsector+2
00A4D7  2  A5 6A          lda fat32_lastsector+3
00A4D9  2  85 45          sta zp_sd_currentsector+3
00A4DB  2               
00A4DB  2                 ; Target buffer
00A4DB  2  A9 00          lda #<fat32_readbuffer
00A4DD  2  85 40          sta zp_sd_address
00A4DF  2  A9 02          lda #>fat32_readbuffer
00A4E1  2  85 41          sta zp_sd_address+1
00A4E3  2               
00A4E3  2                 ; Write the FAT sector
00A4E3  2  20 FA A1       jsr sd_writesector
00A4E6  2               
00A4E6  2                 ; Check if FAT mirroring is enabled
00A4E6  2  A5 6E          lda fat32_numfats
00A4E8  2  C9 02          cmp #2
00A4EA  2  D0 1B          bne _onefat
00A4EC  2               
00A4EC  2                 ; Add the last sector to the amount of sectors per FAT
00A4EC  2                 ; (to get the second fat location)
00A4EC  2  A5 67          lda fat32_lastsector
00A4EE  2  65 73          adc fat32_sectorsperfat
00A4F0  2  85 42          sta zp_sd_currentsector
00A4F2  2  A5 68          lda fat32_lastsector+1
00A4F4  2  65 74          adc fat32_sectorsperfat+1
00A4F6  2  85 43          sta zp_sd_currentsector+1
00A4F8  2  A5 69          lda fat32_lastsector+2
00A4FA  2  65 75          adc fat32_sectorsperfat+2
00A4FC  2  85 44          sta zp_sd_currentsector+2
00A4FE  2  A5 6A          lda fat32_lastsector+3
00A500  2  65 76          adc fat32_sectorsperfat+3
00A502  2  85 45          sta zp_sd_currentsector+3
00A504  2               
00A504  2                 ; Write the FAT sector
00A504  2  20 FA A1       jsr sd_writesector
00A507  2               
00A507  2               _onefat:
00A507  2                 ; Pull back the current sector
00A507  2  68             pla
00A508  2  85 45          sta zp_sd_currentsector+3
00A50A  2  68             pla
00A50B  2  85 44          sta zp_sd_currentsector+2
00A50D  2  68             pla
00A50E  2  85 43          sta zp_sd_currentsector+1
00A510  2  68             pla
00A511  2  85 42          sta zp_sd_currentsector
00A513  2               
00A513  2  60             rts
00A514  2               
00A514  2               fat32_openroot:
00A514  2                 ; Prepare to read the root directory
00A514  2               
00A514  2  A5 4E          lda fat32_rootcluster
00A516  2  85 56          sta fat32_nextcluster
00A518  2  A5 4F          lda fat32_rootcluster+1
00A51A  2  85 57          sta fat32_nextcluster+1
00A51C  2  A5 50          lda fat32_rootcluster+2
00A51E  2  85 58          sta fat32_nextcluster+2
00A520  2  A5 51          lda fat32_rootcluster+3
00A522  2  85 59          sta fat32_nextcluster+3
00A524  2               
00A524  2  18             clc
00A525  2  20 86 A3       jsr fat32_seekcluster
00A528  2               
00A528  2                 ; Set the pointer to a large value so we always read a sector the first time through
00A528  2  A9 FF          lda #$ff
00A52A  2  85 41          sta zp_sd_address+1
00A52C  2               
00A52C  2  60             rts
00A52D  2               
00A52D  2               fat32_allocatecluster:
00A52D  2                 ; Allocate a cluster to start storing a file at.
00A52D  2               
00A52D  2                 ; Find a free cluster
00A52D  2  20 08 A6       jsr fat32_findnextfreecluster
00A530  2               
00A530  2                 ; Cache the value so we can add the address of the next one later, if any
00A530  2  A5 5E          lda fat32_lastfoundfreecluster
00A532  2  85 62          sta fat32_lastcluster
00A534  2  85 6F          sta fat32_filecluster
00A536  2  A5 5F          lda fat32_lastfoundfreecluster+1
00A538  2  85 63          sta fat32_lastcluster+1
00A53A  2  85 70          sta fat32_filecluster+1
00A53C  2  A5 60          lda fat32_lastfoundfreecluster+2
00A53E  2  85 64          sta fat32_lastcluster+2
00A540  2  85 71          sta fat32_filecluster+2
00A542  2  A5 61          lda fat32_lastfoundfreecluster+3
00A544  2  85 65          sta fat32_lastcluster+3
00A546  2  85 72          sta fat32_filecluster+3
00A548  2               
00A548  2                 ; Add marker for the following routines, so we don't think this is free.
00A548  2                 ; (zp_sd_address),y is controlled by fat32_seekcluster, called in fat32_findnextfreecluster
00A548  2                 ; this points to the most significant byte in the last selected 32-bit FAT entry.
00A548  2  A9 0F          lda #$0f
00A54A  2  91 40          sta (zp_sd_address),y
00A54C  2               
00A54C  2  60             rts
00A54D  2               
00A54D  2               fat32_allocatefile:
00A54D  2                 ; Allocate an entire file in the FAT, with the
00A54D  2                 ; file's size in fat32_bytesremaining
00A54D  2               
00A54D  2                 ; We will read a new sector the first time around
00A54D  2  A5 67          lda fat32_lastsector
00A54F  2  85 42          sta zp_sd_currentsector
00A551  2  A5 68          lda fat32_lastsector+1
00A553  2  85 42          sta zp_sd_currentsector
00A555  2  A5 69          lda fat32_lastsector+2
00A557  2  85 42          sta zp_sd_currentsector
00A559  2  A5 6A          lda fat32_lastsector+3
00A55B  2  85 42          sta zp_sd_currentsector
00A55D  2               
00A55D  2                 ; Allocate the first cluster.
00A55D  2  20 2D A5       jsr fat32_allocatecluster
00A560  2               
00A560  2                 ; We don't properly support 64k+ files, as it's unnecessary complication given
00A560  2                 ; the 6502's small address space. So we'll just empty out the top two bytes.
00A560  2  A9 00          lda #0
00A562  2  85 5C          sta fat32_bytesremaining+2
00A564  2  85 5D          sta fat32_bytesremaining+3
00A566  2               
00A566  2                 ; Stash filesize, as we will be clobbering it here
00A566  2  A5 5A          lda fat32_bytesremaining
00A568  2  48             pha
00A569  2  A5 5B          lda fat32_bytesremaining+1
00A56B  2  48             pha
00A56C  2               
00A56C  2                 ; Round the size up to the next whole sector
00A56C  2  A5 5A          lda fat32_bytesremaining
00A56E  2  C9 01          cmp #1                      ; set carry if bottom 8 bits not zero
00A570  2  A5 5B          lda fat32_bytesremaining+1
00A572  2  69 00          adc #0                      ; add carry, if any
00A574  2  4A             lsr                         ; divide by 2
00A575  2  69 00          adc #0                      ; round up
00A577  2               
00A577  2                 ; No data?
00A577  2  D0 03          bne _nofail
00A579  2  4C 01 A6       jmp _lastclusterdone
00A57C  2               
00A57C  2               _nofail:
00A57C  2                 ; This will be clustersremaining now.
00A57C  2  85 5A          sta fat32_bytesremaining
00A57E  2               
00A57E  2                 ; Divide by sectors per cluster (power of 2)
00A57E  2                 ; If it's 1, then skip
00A57E  2  A5 52          lda fat32_sectorspercluster
00A580  2  C9 01          cmp #1
00A582  2  F0 06          beq _one
00A584  2               
00A584  2  4A             lsr
00A585  2               _cl:
00A585  2  46 5A          lsr fat32_bytesremaining
00A587  2  4A             lsr
00A588  2  90 FB          bcc _cl
00A58A  2               
00A58A  2               _one:
00A58A  2               
00A58A  2                 ; We will be making a new cluster every time
00A58A  2  A5 53          lda fat32_pendingsectors
00A58C  2  85 42          sta zp_sd_currentsector
00A58E  2               
00A58E  2                 ; Find free clusters and allocate them for use for this file.
00A58E  2               _allocateloop:
00A58E  2                 ; Check if it's the last cluster in the chain
00A58E  2  A5 5A          lda fat32_bytesremaining
00A590  2  F0 04          beq _lastcluster
00A592  2  C9 01          cmp #1                 ; CHECK! is 1 the right amound for this?
00A594  2  90 29          bcc _notlastcluster     ; clustersremaining <=1?
00A596  2               
00A596  2                 ; It is the last one.
00A596  2               
00A596  2               _lastcluster:
00A596  2               
00A596  2               ; go back the previous one
00A596  2  A5 62          lda fat32_lastcluster
00A598  2  85 56          sta fat32_nextcluster
00A59A  2  A5 63          lda fat32_lastcluster+1
00A59C  2  85 57          sta fat32_nextcluster+1
00A59E  2  A5 64          lda fat32_lastcluster+2
00A5A0  2  85 58          sta fat32_nextcluster+2
00A5A2  2  A5 65          lda fat32_lastcluster+3
00A5A4  2  85 59          sta fat32_nextcluster+3
00A5A6  2               
00A5A6  2  38             sec
00A5A7  2  20 86 A3       jsr fat32_seekcluster
00A5AA  2               
00A5AA  2                 ; Write 0x0FFFFFFF (EOC)
00A5AA  2  A9 0F          lda #$0f
00A5AC  2  91 40          sta (zp_sd_address),y
00A5AE  2  88             dey
00A5AF  2  A9 FF          lda #$ff
00A5B1  2  91 40          sta (zp_sd_address),y
00A5B3  2  88             dey
00A5B4  2  91 40          sta (zp_sd_address),y
00A5B6  2  88             dey
00A5B7  2  91 40          sta (zp_sd_address),y
00A5B9  2               
00A5B9  2                 ; Update the FAT
00A5B9  2  20 BF A4       jsr fat32_updatefat
00A5BC  2               
00A5BC  2                 ; End of chain - exit
00A5BC  2  4C 01 A6       jmp _lastclusterdone
00A5BF  2               
00A5BF  2               _notlastcluster:
00A5BF  2                 ; Wait! Is there exactly 1 cluster left?
00A5BF  2  F0 D5          beq _lastcluster
00A5C1  2               
00A5C1  2                 ; Find the next cluster
00A5C1  2  20 08 A6       jsr fat32_findnextfreecluster
00A5C4  2               
00A5C4  2                 ; Add marker so we don't think this is free.
00A5C4  2  A9 0F          lda #$0f
00A5C6  2  91 40          sta (zp_sd_address),y
00A5C8  2               
00A5C8  2                 ; Seek to the previous cluster
00A5C8  2  A5 62          lda fat32_lastcluster
00A5CA  2  85 56          sta fat32_nextcluster
00A5CC  2  A5 63          lda fat32_lastcluster+1
00A5CE  2  85 57          sta fat32_nextcluster+1
00A5D0  2  A5 64          lda fat32_lastcluster+2
00A5D2  2  85 58          sta fat32_nextcluster+2
00A5D4  2  A5 65          lda fat32_lastcluster+3
00A5D6  2  85 59          sta fat32_nextcluster+3
00A5D8  2               
00A5D8  2  38             sec
00A5D9  2  20 86 A3       jsr fat32_seekcluster
00A5DC  2               
00A5DC  2                 ; Enter the address of the next one into the FAT
00A5DC  2  A5 61          lda fat32_lastfoundfreecluster+3
00A5DE  2  85 65          sta fat32_lastcluster+3
00A5E0  2  91 40          sta (zp_sd_address),y
00A5E2  2  88             dey
00A5E3  2  A5 60          lda fat32_lastfoundfreecluster+2
00A5E5  2  85 64          sta fat32_lastcluster+2
00A5E7  2  91 40          sta (zp_sd_address),y
00A5E9  2  88             dey
00A5EA  2  A5 5F          lda fat32_lastfoundfreecluster+1
00A5EC  2  85 63          sta fat32_lastcluster+1
00A5EE  2  91 40          sta (zp_sd_address),y
00A5F0  2  88             dey
00A5F1  2  A5 5E          lda fat32_lastfoundfreecluster
00A5F3  2  85 62          sta fat32_lastcluster
00A5F5  2  91 40          sta (zp_sd_address),y
00A5F7  2               
00A5F7  2                 ; Update the FAT
00A5F7  2  20 BF A4       jsr fat32_updatefat
00A5FA  2               
00A5FA  2  A6 5A          ldx fat32_bytesremaining    ; note - actually loads clusters remaining
00A5FC  2  CA             dex
00A5FD  2  86 5A          stx fat32_bytesremaining    ; note - actually stores clusters remaining
00A5FF  2               
00A5FF  2  D0 8D          bne _allocateloop
00A601  2               
00A601  2                 ; Done!
00A601  2               _lastclusterdone:
00A601  2                 ; Pull the filesize back from the stack
00A601  2  68             pla
00A602  2  85 5B          sta fat32_bytesremaining+1
00A604  2  68             pla
00A605  2  85 5A          sta fat32_bytesremaining
00A607  2  60             rts
00A608  2               
00A608  2               
00A608  2               fat32_findnextfreecluster:
00A608  2               ; Find next free cluster
00A608  2               ;
00A608  2               ; This program will search the FAT for an empty entry, and
00A608  2               ; save the 32-bit cluster number at fat32_lastfoundfreecluter.
00A608  2               ;
00A608  2               ; Also sets the carry bit if the SD card is full.
00A608  2               ;
00A608  2               
00A608  2                 ; Find a free cluster and store it's location in fat32_lastfoundfreecluster
00A608  2               
00A608  2  A9 00          lda #0
00A60A  2  85 56          sta fat32_nextcluster
00A60C  2  85 5E          sta fat32_lastfoundfreecluster
00A60E  2  85 57          sta fat32_nextcluster+1
00A610  2  85 5F          sta fat32_lastfoundfreecluster+1
00A612  2  85 58          sta fat32_nextcluster+2
00A614  2  85 60          sta fat32_lastfoundfreecluster+2
00A616  2  85 59          sta fat32_nextcluster+3
00A618  2  85 61          sta fat32_lastfoundfreecluster+3
00A61A  2               
00A61A  2               _searchclusters:
00A61A  2               
00A61A  2                 ; Seek cluster
00A61A  2  38             sec
00A61B  2  20 86 A3       jsr fat32_seekcluster
00A61E  2               
00A61E  2                 ; Is the cluster free?
00A61E  2  A5 56          lda fat32_nextcluster
00A620  2  29 0F          and #$0f
00A622  2  05 57          ora fat32_nextcluster+1
00A624  2  05 58          ora fat32_nextcluster+2
00A626  2  05 59          ora fat32_nextcluster+3
00A628  2  F0 21          beq _foundcluster
00A62A  2               
00A62A  2                 ; No, increment the cluster count
00A62A  2  E6 5E          inc fat32_lastfoundfreecluster
00A62C  2  D0 0A          bne _copycluster
00A62E  2  E6 5F          inc fat32_lastfoundfreecluster+1
00A630  2  D0 06          bne _copycluster
00A632  2  E6 60          inc fat32_lastfoundfreecluster+2
00A634  2  D0 02          bne _copycluster
00A636  2  E6 61          inc fat32_lastfoundfreecluster+3
00A638  2               
00A638  2               _copycluster:
00A638  2               
00A638  2                 ; Copy the cluster count to the next cluster
00A638  2  A5 5E          lda fat32_lastfoundfreecluster
00A63A  2  85 56          sta fat32_nextcluster
00A63C  2  A5 5F          lda fat32_lastfoundfreecluster+1
00A63E  2  85 57          sta fat32_nextcluster+1
00A640  2  A5 60          lda fat32_lastfoundfreecluster+2
00A642  2  85 58          sta fat32_nextcluster+2
00A644  2  A5 61          lda fat32_lastfoundfreecluster+3
00A646  2  85 59          sta fat32_nextcluster+3
00A648  2               
00A648  2                 ; Go again for another pass
00A648  2  4C 1A A6       jmp _searchclusters
00A64B  2               
00A64B  2               _foundcluster:
00A64B  2                 ; done.
00A64B  2  60             rts
00A64C  2               
00A64C  2               fat32_opendirent:
00A64C  2                 ; Prepare to read/write a file or directory based on a dirent
00A64C  2                 ;
00A64C  2                 ; Point zp_sd_address at the dirent
00A64C  2               
00A64C  2                 ; Remember file size in bytes remaining
00A64C  2  A0 1C          ldy #28
00A64E  2  B1 40          lda (zp_sd_address),y
00A650  2  85 5A          sta fat32_bytesremaining
00A652  2  C8             iny
00A653  2  B1 40          lda (zp_sd_address),y
00A655  2  85 5B          sta fat32_bytesremaining+1
00A657  2  C8             iny
00A658  2  B1 40          lda (zp_sd_address),y
00A65A  2  85 5C          sta fat32_bytesremaining+2
00A65C  2  C8             iny
00A65D  2  B1 40          lda (zp_sd_address),y
00A65F  2  85 5D          sta fat32_bytesremaining+3
00A661  2               
00A661  2                 ; Seek to first cluster
00A661  2  A0 1A          ldy #26
00A663  2  B1 40          lda (zp_sd_address),y
00A665  2  85 56          sta fat32_nextcluster
00A667  2  C8             iny
00A668  2  B1 40          lda (zp_sd_address),y
00A66A  2  85 57          sta fat32_nextcluster+1
00A66C  2  A0 14          ldy #20
00A66E  2  B1 40          lda (zp_sd_address),y
00A670  2  85 58          sta fat32_nextcluster+2
00A672  2  C8             iny
00A673  2  B1 40          lda (zp_sd_address),y
00A675  2  85 59          sta fat32_nextcluster+3
00A677  2               
00A677  2  18             clc
00A678  2  20 86 A3       jsr fat32_seekcluster
00A67B  2               
00A67B  2                 ; Set the pointer to a large value so we always read a sector the first time through
00A67B  2  A9 FF          lda #$ff
00A67D  2  85 41          sta zp_sd_address+1
00A67F  2               
00A67F  2  60             rts
00A680  2               
00A680  2               fat32_writedirent:
00A680  2                 ; Write a directory entry from the open directory
00A680  2                 ; requires:
00A680  2                 ;   fat32bytesremaining (2 bytes) = file size in bytes (little endian)
00A680  2               
00A680  2                 ; Increment pointer by 32 to point to next entry
00A680  2  18             clc
00A681  2  A5 40          lda zp_sd_address
00A683  2  69 20          adc #32
00A685  2  85 40          sta zp_sd_address
00A687  2  A5 41          lda zp_sd_address+1
00A689  2  69 00          adc #0
00A68B  2  85 41          sta zp_sd_address+1
00A68D  2               
00A68D  2                 ; If it's not at the end of the buffer, we have data already
00A68D  2  C9 04          cmp #>(fat32_readbuffer+$200)
00A68F  2  90 0F          bcc _gotdirrent
00A691  2               
00A691  2                 ; Read another sector
00A691  2  A9 00          lda #<fat32_readbuffer
00A693  2  85 54          sta fat32_address
00A695  2  A9 02          lda #>fat32_readbuffer
00A697  2  85 55          sta fat32_address+1
00A699  2               
00A699  2  20 62 A4       jsr fat32_readnextsector
00A69C  2  90 02          bcc _gotdirrent
00A69E  2               
00A69E  2               _endofdirectorywrite:
00A69E  2  38             sec
00A69F  2  60             rts
00A6A0  2               
00A6A0  2               _gotdirrent:
00A6A0  2                 ; Check first character
00A6A0  2  18             clc
00A6A1  2  A0 00          ldy #0
00A6A3  2  B1 40          lda (zp_sd_address),y
00A6A5  2  D0 D9          bne fat32_writedirent ; go again
00A6A7  2                 ; End of directory. Now make a new entry.
00A6A7  2               _dloop:
00A6A7  2  B1 6C          lda (fat32_filenamepointer),y	; copy filename
00A6A9  2  91 40          sta (zp_sd_address),y
00A6AB  2  C8             iny
00A6AC  2  C0 0B          cpy #$0b
00A6AE  2  D0 F7          bne _dloop
00A6B0  2                 ; The full Short filename is #11 bytes long so,
00A6B0  2                 ; this start at 0x0b - File type
00A6B0  2                 ; BUG assumes that we are making a file, not a folder...
00A6B0  2  A9 20          lda #$20		; File Type: ARCHIVE
00A6B2  2  91 40          sta (zp_sd_address),y
00A6B4  2  C8             iny   ; 0x0c - Checksum/File accsess password
00A6B5  2  A9 10          lda #$10		            ; No checksum or password
00A6B7  2  91 40          sta (zp_sd_address),y
00A6B9  2  C8             iny   ; 0x0d - first char of deleted file - 0x7d for nothing
00A6BA  2  A9 7D          lda #$7D
00A6BC  2  91 40          sta (zp_sd_address),y
00A6BE  2  C8             iny	; 0x0e-0x11 - File creation time/date
00A6BF  2  A9 00          lda #0
00A6C1  2               _empty:
00A6C1  2  91 40          sta (zp_sd_address),y	; No time/date because I don't have an RTC
00A6C3  2  C8             iny
00A6C4  2  C0 14          cpy #$14 ; also empty the user ID (0x12-0x13)
00A6C6  2  D0 F9          bne _empty
00A6C8  2                 ; 0x14-0x15 - File start cluster (high word)
00A6C8  2  A5 60          lda fat32_lastfoundfreecluster+2
00A6CA  2  91 40          sta (zp_sd_address),y
00A6CC  2  C8             iny
00A6CD  2  A5 61          lda fat32_lastfoundfreecluster+3
00A6CF  2  91 40          sta (zp_sd_address),y
00A6D1  2  C8             iny ; 0x16-0x19 - File modifiaction date
00A6D2  2  A9 00          lda #0
00A6D4  2  91 40          sta (zp_sd_address),y
00A6D6  2  C8             iny
00A6D7  2  91 40          sta (zp_sd_address),y   ; no rtc
00A6D9  2  C8             iny
00A6DA  2  91 40          sta (zp_sd_address),y
00A6DC  2  C8             iny
00A6DD  2  91 40          sta (zp_sd_address),y
00A6DF  2  C8             iny ; 0x1a-0x1b - File start cluster (low word)
00A6E0  2  A5 5E          lda fat32_lastfoundfreecluster
00A6E2  2  91 40          sta (zp_sd_address),y
00A6E4  2  C8             iny
00A6E5  2  A5 5F          lda fat32_lastfoundfreecluster+1
00A6E7  2  91 40          sta (zp_sd_address),y
00A6E9  2  C8             iny ; 0x1c-0x1f File size in bytes
00A6EA  2  A5 5A          lda fat32_bytesremaining
00A6EC  2  91 40          sta (zp_sd_address),y
00A6EE  2  C8             iny
00A6EF  2  A5 5B          lda fat32_bytesremaining+1
00A6F1  2  91 40          sta (zp_sd_address),y
00A6F3  2  C8             iny
00A6F4  2  A9 00          lda #0
00A6F6  2  91 40          sta (zp_sd_address),y ; No bigger that 64k
00A6F8  2  C8             iny
00A6F9  2  91 40          sta (zp_sd_address),y
00A6FB  2  C8             iny
00A6FC  2                 ; are we over the buffer?
00A6FC  2  A5 41          lda zp_sd_address+1
00A6FE  2  C9 04          cmp #>(fat32_readbuffer+$200)
00A700  2  90 12          bcc _notoverbuffer
00A702  2  20 37 A7       jsr fat32_writecurrentsector ; if so, write the current sector
00A705  2  20 62 A4       jsr fat32_readnextsector  ; then read the next one.
00A708  2  B0 2B          bcs _dfail
00A70A  2  A0 00          ldy #0
00A70C  2  A9 00          lda #<fat32_readbuffer
00A70E  2  85 40          sta zp_sd_address
00A710  2  A9 02          lda #>fat32_readbuffer
00A712  2  85 41          sta zp_sd_address+1
00A714  2               _notoverbuffer:
00A714  2                 ; next entry is 0 (end of dir)
00A714  2  A9 00          lda #0
00A716  2  91 40          sta (zp_sd_address),y
00A718  2                 ; Write the dirent.
00A718  2  20 37 A7       jsr fat32_writecurrentsector
00A71B  2               
00A71B  2                 ; Great, lets get this ready for other code to read in.
00A71B  2               
00A71B  2                 ; Seek to first cluster
00A71B  2  A5 6F          lda fat32_filecluster
00A71D  2  85 56          sta fat32_nextcluster
00A71F  2  A5 70          lda fat32_filecluster+1
00A721  2  85 57          sta fat32_nextcluster+1
00A723  2  A5 71          lda fat32_filecluster+2
00A725  2  85 58          sta fat32_nextcluster+2
00A727  2  A5 72          lda fat32_filecluster+3
00A729  2  85 59          sta fat32_nextcluster+3
00A72B  2               
00A72B  2  18             clc
00A72C  2  20 86 A3       jsr fat32_seekcluster
00A72F  2               
00A72F  2                 ; Set the pointer to a large value so we always read a sector the first time through
00A72F  2  A9 FF          lda #$ff
00A731  2  85 41          sta zp_sd_address+1
00A733  2               
00A733  2  18             clc
00A734  2  60             rts
00A735  2               
00A735  2               _dfail:
00A735  2                 ; Card Full
00A735  2  38             sec
00A736  2  60             rts
00A737  2               
00A737  2               fat32_writecurrentsector:
00A737  2               
00A737  2                 ; decrement the sector so we write the current one (not the next one)
00A737  2  A5 42          lda zp_sd_currentsector
00A739  2  D0 0A          bne _skip
00A73B  2  C6 43          dec zp_sd_currentsector+1
00A73D  2  D0 06          bne _skip
00A73F  2  C6 44          dec zp_sd_currentsector+2
00A741  2  D0 02          bne _skip
00A743  2  C6 45          dec zp_sd_currentsector+3
00A745  2               
00A745  2               _skip:
00A745  2  C6 42          dec zp_sd_currentsector
00A747  2               
00A747  2               _nodec:
00A747  2               
00A747  2  A5 54          lda fat32_address
00A749  2  85 40          sta zp_sd_address
00A74B  2  A5 55          lda fat32_address+1
00A74D  2  85 41          sta zp_sd_address+1
00A74F  2               
00A74F  2                 ; Read the sector
00A74F  2  20 FA A1       jsr sd_writesector
00A752  2               
00A752  2                 ; Advance to next sector
00A752  2  E6 42          inc zp_sd_currentsector
00A754  2  D0 0A          bne _writesectorincrementdone
00A756  2  E6 43          inc zp_sd_currentsector+1
00A758  2  D0 06          bne _writesectorincrementdone
00A75A  2  E6 44          inc zp_sd_currentsector+2
00A75C  2  D0 02          bne _writesectorincrementdone
00A75E  2  E6 45          inc zp_sd_currentsector+3
00A760  2               
00A760  2               _writesectorincrementdone:
00A760  2  60             rts
00A761  2               
00A761  2               fat32_readdirent:
00A761  2                 ; Read a directory entry from the open directory
00A761  2                 ;
00A761  2                 ; On exit the carry is set if there were no more directory entries.
00A761  2                 ;
00A761  2                 ; Otherwise, A is set to the file's attribute byte and
00A761  2                 ; zp_sd_address points at the returned directory entry.
00A761  2                 ; LFNs and empty entries are ignored automatically.
00A761  2               
00A761  2                 ; Increment pointer by 32 to point to next entry
00A761  2  18             clc
00A762  2  A5 40          lda zp_sd_address
00A764  2  69 20          adc #32
00A766  2  85 40          sta zp_sd_address
00A768  2  A5 41          lda zp_sd_address+1
00A76A  2  69 00          adc #0
00A76C  2  85 41          sta zp_sd_address+1
00A76E  2               
00A76E  2                 ; If it's not at the end of the buffer, we have data already
00A76E  2  C9 04          cmp #>(fat32_readbuffer+$200)
00A770  2  90 0F          bcc _gotdirdata
00A772  2                 ; Read another sector
00A772  2  A9 00          lda #<fat32_readbuffer
00A774  2  85 54          sta fat32_address
00A776  2  A9 02          lda #>fat32_readbuffer
00A778  2  85 55          sta fat32_address+1
00A77A  2               
00A77A  2  20 62 A4       jsr fat32_readnextsector
00A77D  2  90 02          bcc _gotdirdata
00A77F  2               _endofdirectory:
00A77F  2  38             sec
00A780  2  60             rts
00A781  2               
00A781  2               _gotdirdata:
00A781  2                 ; Check first character
00A781  2  A0 00          ldy #0
00A783  2  B1 40          lda (zp_sd_address),y
00A785  2               
00A785  2                 ; End of directory => abort
00A785  2  F0 F8          beq _endofdirectory
00A787  2               
00A787  2                 ; Empty entry => start again
00A787  2  C9 E5          cmp #$e5
00A789  2  F0 D6          beq fat32_readdirent
00A78B  2               
00A78B  2                 ; Check attributes
00A78B  2  A0 0B          ldy #11
00A78D  2  B1 40          lda (zp_sd_address),y
00A78F  2  29 3F          and #$3f
00A791  2  C9 0F          cmp #$0f ; LFN => start again
00A793  2  F0 CC          beq fat32_readdirent
00A795  2               
00A795  2                 ; Yield this result
00A795  2  18             clc
00A796  2  60             rts
00A797  2               
00A797  2               
00A797  2               fat32_finddirent:
00A797  2                 ; Finds a particular directory entry. X,Y point to the 11-character filename to seek.
00A797  2                 ; The directory should already be open for iteration.
00A797  2               
00A797  2                 ; Form ZP pointer to user's filename
00A797  2  86 6C          stx fat32_filenamepointer
00A799  2  84 6D          sty fat32_filenamepointer+1
00A79B  2                 ; Iterate until name is found or end of directory
00A79B  2               _direntloop:
00A79B  2  20 61 A7       jsr fat32_readdirent
00A79E  2  A0 0A          ldy #10
00A7A0  2  90 01          bcc _comparenameloop
00A7A2  2  60             rts ; with carry set
00A7A3  2               
00A7A3  2               _comparenameloop:
00A7A3  2  B1 40          lda (zp_sd_address),y
00A7A5  2  D1 6C          cmp (fat32_filenamepointer),y
00A7A7  2  D0 F2          bne _direntloop ; no match
00A7A9  2  88             dey
00A7AA  2  10 F7          bpl _comparenameloop
00A7AC  2                 ; Found it
00A7AC  2  18             clc
00A7AD  2  60             rts
00A7AE  2               
00A7AE  2               fat32_markdeleted:
00A7AE  2                 ; Mark the file as deleted
00A7AE  2                 ; We need to stash the first character at index 0x0D
00A7AE  2  A0 00          ldy #$00
00A7B0  2  B1 40          lda (zp_sd_address),y
00A7B2  2  A0 0D          ldy #$0d
00A7B4  2  91 40          sta (zp_sd_address),y
00A7B6  2               
00A7B6  2                 ; Now put 0xE5 at the first byte
00A7B6  2  A0 00          ldy #$00
00A7B8  2  A9 E5          lda #$e5
00A7BA  2  91 40          sta (zp_sd_address),y
00A7BC  2               
00A7BC  2                 ; Get start cluster high word
00A7BC  2  A0 14          ldy #$14
00A7BE  2  B1 40          lda (zp_sd_address),y
00A7C0  2  85 58          sta fat32_nextcluster+2
00A7C2  2  C8             iny
00A7C3  2  B1 40          lda (zp_sd_address),y
00A7C5  2  85 59          sta fat32_nextcluster+3
00A7C7  2               
00A7C7  2                 ; And low word
00A7C7  2  A0 1A          ldy #$1a
00A7C9  2  B1 40          lda (zp_sd_address),y
00A7CB  2  85 56          sta fat32_nextcluster
00A7CD  2  C8             iny
00A7CE  2  B1 40          lda (zp_sd_address),y
00A7D0  2  85 57          sta fat32_nextcluster+1
00A7D2  2               
00A7D2  2                 ; Write the dirent
00A7D2  2  20 37 A7       jsr fat32_writecurrentsector
00A7D5  2               
00A7D5  2                 ; Done
00A7D5  2  18             clc
00A7D6  2  60             rts
00A7D7  2               
00A7D7  2               fat32_deletefile:
00A7D7  2                 ; Removes the open file from the SD card.
00A7D7  2                 ; The directory needs to be open and
00A7D7  2                 ; zp_sd_address pointed to the first byte of the file entry.
00A7D7  2               
00A7D7  2                 ; Mark the file as "Removed"
00A7D7  2  20 AE A7       jsr fat32_markdeleted
00A7DA  2               
00A7DA  2                 ; We will read a new sector the first time around
00A7DA  2  A5 67          lda fat32_lastsector
00A7DC  2  85 42          sta zp_sd_currentsector
00A7DE  2  A5 68          lda fat32_lastsector+1
00A7E0  2  85 42          sta zp_sd_currentsector
00A7E2  2  A5 69          lda fat32_lastsector+2
00A7E4  2  85 42          sta zp_sd_currentsector
00A7E6  2  A5 6A          lda fat32_lastsector+3
00A7E8  2  85 42          sta zp_sd_currentsector
00A7EA  2               
00A7EA  2                 ; Now we need to iterate through this file's cluster chain, and remove it from the FAT.
00A7EA  2  A0 00          ldy #0
00A7EC  2               _chainloop:
00A7EC  2                 ; Seek to cluster
00A7EC  2  38             sec
00A7ED  2  20 86 A3       jsr fat32_seekcluster
00A7F0  2               
00A7F0  2                 ; Is this the end of the chain?
00A7F0  2  A5 59          lda fat32_nextcluster+3
00A7F2  2  30 13          bmi _deletefileendofchain
00A7F4  2               
00A7F4  2                 ; Zero it out
00A7F4  2  A9 00          lda #0
00A7F6  2  91 40          sta (zp_sd_address),y
00A7F8  2  88             dey
00A7F9  2  91 40          sta (zp_sd_address),y
00A7FB  2  88             dey
00A7FC  2  91 40          sta (zp_sd_address),y
00A7FE  2  88             dey
00A7FF  2  91 40          sta (zp_sd_address),y
00A801  2               
00A801  2                 ; Write the FAT
00A801  2  20 BF A4       jsr fat32_updatefat
00A804  2               
00A804  2                 ; And go again for another pass.
00A804  2  4C EC A7       jmp _chainloop
00A807  2               
00A807  2               _deletefileendofchain:
00A807  2                 ; This is the last cluster in the chain.
00A807  2               
00A807  2                 ; Just zero it out,
00A807  2  A9 00          lda #0
00A809  2  91 40          sta (zp_sd_address),y
00A80B  2  88             dey
00A80C  2  91 40          sta (zp_sd_address),y
00A80E  2  88             dey
00A80F  2  91 40          sta (zp_sd_address),y
00A811  2  88             dey
00A812  2  91 40          sta (zp_sd_address),y
00A814  2               
00A814  2                 ; Write the FAT
00A814  2  20 BF A4       jsr fat32_updatefat
00A817  2               
00A817  2                 ; And we're done!
00A817  2  18             clc
00A818  2  60             rts
00A819  2               
00A819  2               fat32_file_readbyte:
00A819  2                 ; Read a byte from an open file
00A819  2                 ;
00A819  2                 ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
00A819  2               
00A819  2  38             sec
00A81A  2               
00A81A  2                 ; Is there any data to read at all?
00A81A  2  A5 5A          lda fat32_bytesremaining
00A81C  2  05 5B          ora fat32_bytesremaining+1
00A81E  2  05 5C          ora fat32_bytesremaining+2
00A820  2  05 5D          ora fat32_bytesremaining+3
00A822  2  F0 3D          beq _rts
00A824  2               
00A824  2                 ; Decrement the remaining byte count
00A824  2  A5 5A          lda fat32_bytesremaining
00A826  2  E9 01          sbc #1
00A828  2  85 5A          sta fat32_bytesremaining
00A82A  2  A5 5B          lda fat32_bytesremaining+1
00A82C  2  E9 00          sbc #0
00A82E  2  85 5B          sta fat32_bytesremaining+1
00A830  2  A5 5C          lda fat32_bytesremaining+2
00A832  2  E9 00          sbc #0
00A834  2  85 5C          sta fat32_bytesremaining+2
00A836  2  A5 5D          lda fat32_bytesremaining+3
00A838  2  E9 00          sbc #0
00A83A  2  85 5D          sta fat32_bytesremaining+3
00A83C  2               
00A83C  2                 ; Need to read a new sector?
00A83C  2  A5 41          lda zp_sd_address+1
00A83E  2  C9 04          cmp #>(fat32_readbuffer+$200)
00A840  2  90 0D          bcc _gotdata
00A842  2               
00A842  2                 ; Read another sector
00A842  2  A9 00          lda #<fat32_readbuffer
00A844  2  85 54          sta fat32_address
00A846  2  A9 02          lda #>fat32_readbuffer
00A848  2  85 55          sta fat32_address+1
00A84A  2               
00A84A  2  20 62 A4       jsr fat32_readnextsector
00A84D  2  B0 12          bcs _rts                    ; this shouldn't happen
00A84F  2               
00A84F  2               _gotdata:
00A84F  2  A0 00          ldy #0
00A851  2  B1 40          lda (zp_sd_address),y
00A853  2               
00A853  2  E6 40          inc zp_sd_address
00A855  2  D0 0A          bne _rts
00A857  2  E6 41          inc zp_sd_address+1
00A859  2  D0 06          bne _rts
00A85B  2  E6 42          inc zp_sd_address+2
00A85D  2  D0 02          bne _rts
00A85F  2  E6 43          inc zp_sd_address+3
00A861  2               
00A861  2               _rts:
00A861  2  60             rts
00A862  2               
00A862  2               
00A862  2               fat32_file_read:
00A862  2                 ; Read a whole file into memory.  It's assumed the file has just been opened
00A862  2                 ; and no data has been read yet.
00A862  2                 ;
00A862  2                 ; Also we read whole sectors, so data in the target region beyond the end of the
00A862  2                 ; file may get overwritten, up to the next 512-byte boundary.
00A862  2                 ;
00A862  2                 ; And we don't properly support 64k+ files, as it's unnecessary complication given
00A862  2                 ; the 6502's small address space
00A862  2               
00A862  2                 ; Round the size up to the next whole sector
00A862  2  A5 5A          lda fat32_bytesremaining
00A864  2  C9 01          cmp #1                      ; set carry if bottom 8 bits not zero
00A866  2  A5 5B          lda fat32_bytesremaining+1
00A868  2  69 00          adc #0                      ; add carry, if any
00A86A  2  4A             lsr                         ; divide by 2
00A86B  2  69 00          adc #0                      ; round up
00A86D  2               
00A86D  2                 ; No data?
00A86D  2  F0 12          beq _fat32_file_read_done
00A86F  2               
00A86F  2                 ; Store sector count - not a byte count any more
00A86F  2  85 5A          sta fat32_bytesremaining
00A871  2               
00A871  2                 ; Read entire sectors to the user-supplied buffer
00A871  2               _wholesectorreadloop:
00A871  2                 ; Read a sector to fat32_address
00A871  2  20 62 A4       jsr fat32_readnextsector
00A874  2               
00A874  2                 ; Advance fat32_address by 512 bytes
00A874  2  A5 55          lda fat32_address+1
00A876  2  69 02          adc #2                      ; carry already clear
00A878  2  85 55          sta fat32_address+1
00A87A  2               
00A87A  2  A6 5A          ldx fat32_bytesremaining    ; note - actually loads sectors remaining
00A87C  2  CA             dex
00A87D  2  86 5A          stx fat32_bytesremaining    ; note - actually stores sectors remaining
00A87F  2               
00A87F  2  D0 F0          bne _wholesectorreadloop
00A881  2               
00A881  2               _fat32_file_read_done:
00A881  2  60             rts
00A882  2               
00A882  2               
00A882  1                 .include "liboutput.s"
00A882  2               newline:
00A882  2  A9 0D          lda #$0D                   ; CR
00A884  2  20 A0 1E       jsr OUTCH                  ; Send a carriage retuen
00A887  2  A9 0A          lda #$0A                   ; LF
00A889  2  20 A0 1E       jsr OUTCH                  ; Send the line feed
00A88C  2  60             rts
00A88D  2               
00A88D  2               print_char:
00A88D  2  20 A0 1E       jsr OUTCH
00A890  2  60             rts
00A891  2               
00A891  2               print_hex:
00A891  2  48             pha
00A892  2  6A             ror
00A893  2  6A             ror
00A894  2  6A             ror
00A895  2  6A             ror
00A896  2  20 A0 A8       jsr print_nybble
00A899  2  68             pla
00A89A  2  48             pha
00A89B  2  20 A0 A8       jsr print_nybble
00A89E  2  68             pla
00A89F  2  60             rts
00A8A0  2               print_nybble:
00A8A0  2  29 0F          and #15
00A8A2  2  C9 0A          cmp #10
00A8A4  2  30 02          bmi skipletter
00A8A6  2  69 06          adc #6
00A8A8  2               skipletter:
00A8A8  2  69 30          adc #48
00A8AA  2  20 8D A8       jsr print_char
00A8AD  2  60             rts
00A8AE  2               
00A8AE  1               
00A8AE  1               ;  .org $fffc
00A8AE  1  03 A0          .word reset
00A8B0  1  00 00          .word $0000
00A8B2  1               
00A8B2  1               ; Change these to the name of the file and folder you added to the card
00A8B2  1               ; The strings must be 11 charaters long. Format is 8.3, filename.ext
00A8B2  1               subdirname:
00A8B2  1  46 4F 4C 44    .asciiz "FOLDER     "
00A8B6  1  45 52 20 20  
00A8BA  1  20 20 20 00  
00A8BE  1               filename:
00A8BE  1  48 45 4C 4C    .asciiz "HELLO   TXT"
00A8C2  1  4F 20 20 20  
00A8C6  1  54 58 54 00  
00A8C9  1               
